/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __export = (target, all) => {
  __markAsModule(target);
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toModule = (module2) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// src/main.ts
__export(exports, {
  default: () => StateSwitcherPlugin
});
var import_obsidian5 = __toModule(require("obsidian"));

// src/setting.ts
var import_obsidian2 = __toModule(require("obsidian"));

// src/util.ts
var import_obsidian = __toModule(require("obsidian"));
var YAML_REGEX = /^---\n(?:((?:.|\n)*?)\n)?---(?=\n|$)/;
function getObjectYaml(editor) {
  const stringYaml = getYaml(editor);
  return stringYaml ? (0, import_obsidian.parseYaml)(stringYaml.slice(4, -4)) : {};
}
function itemMove(arr, itemIdx1, itemIdx2) {
  [arr[itemIdx1], arr[itemIdx2]] = [arr[itemIdx2], arr[itemIdx1]];
}
function itemAdd(arr, itemIdx, item) {
  arr.splice(itemIdx, 0, item);
}
function itemDelete(arr, itemIndex) {
  arr.splice(itemIndex, 1);
}
function getYaml(editor) {
  var _a;
  const matchResult = editor.getValue().match(YAML_REGEX);
  return (_a = matchResult == null ? void 0 : matchResult[0]) != null ? _a : "";
}
function generateActionKeyword(data) {
  const { editor, action } = data;
  const yamlSection = getYaml(editor);
  const yaml = yamlSection.slice(4, -3);
  const objectYaml = getObjectYaml(editor);
  const objectSnippet = {};
  if (action === "replace")
    objectSnippet[data.key] = data.value;
  if (action === "insert") {
    if (objectYaml[data.key] instanceof Array) {
      objectSnippet[data.key] = [...objectYaml[data.key], data.value];
    } else {
      objectSnippet[data.key] = [data.value];
    }
  }
  if (action === "remove") {
    if (objectYaml[data.key] instanceof Array) {
      const newValue = objectYaml[data.key].filter((val) => val !== data.value);
      objectSnippet[data.key] = newValue.length ? newValue : null;
    } else {
      objectSnippet[data.key] = null;
    }
  }
  if (action === "bulk") {
    Object.entries(data.updateDatas).forEach(([key, value]) => objectSnippet[key] = value);
    data.removeDatas.forEach((key) => objectSnippet[key] = null);
  }
  const replacement = `---
${generateReplacement(yaml, objectSnippet)}---`;
  const startPosition = { line: 0, ch: 0 };
  const endPosition = editor.offsetToPos(yamlSection.length);
  return { replacement, startPosition, endPosition };
}
function generateReplacement(yaml, snippet) {
  return Object.entries(snippet).reduce((temp, [key, value]) => {
    const YAML_FIELD_REGEX = new RegExp(`(${key} *:).+?\\n(?=\\S|$)`, "gs");
    const replacement = value === null ? "" : (0, import_obsidian.stringifyYaml)({ [key]: value });
    return temp.match(YAML_FIELD_REGEX) ? temp.replace(YAML_FIELD_REGEX, replacement) : `${temp}${replacement}`;
  }, yaml);
}
function flatYamlFields(yaml, flatFields) {
  const objectYaml = (0, import_obsidian.parseYaml)(yaml.slice(4, -4));
  return flatFields.reduce((temp, key) => {
    const YAML_FIELD_REGEX = new RegExp(`(${key}:).+?(?=\\n\\S|$)`, "gs");
    return temp.match(YAML_FIELD_REGEX) ? temp.replace(YAML_FIELD_REGEX, `$1 [${objectYaml[key].join(", ")}]`) : temp;
  }, yaml);
}
function replace(key, value, editor) {
  const { replacement, startPosition, endPosition } = generateActionKeyword({ key, value, editor, action: "replace" });
  editor.replaceRange(replacement, startPosition, endPosition);
}
function insert(key, value, flat, editor) {
  const { replacement, startPosition, endPosition } = generateActionKeyword({ key, value, editor, action: "insert" });
  const postProcessedReplacement = flat ? flatYamlFields(replacement, [key]) : replacement;
  editor.replaceRange(postProcessedReplacement, startPosition, endPosition);
}
function remove(key, value, flat, editor) {
  const { replacement, startPosition, endPosition } = generateActionKeyword({ key, value, editor, action: "remove" });
  const postProcessedReplacement = flat ? flatYamlFields(replacement, [key]) : replacement;
  editor.replaceRange(postProcessedReplacement, startPosition, endPosition);
}
function bulkUpdate(updateDatas, removeDatas, flatFields, editor) {
  const { replacement, startPosition, endPosition } = generateActionKeyword({ updateDatas, removeDatas, editor, action: "bulk" });
  const flattedReplacement = flatYamlFields(replacement, flatFields);
  editor.replaceRange(flattedReplacement, startPosition, endPosition);
}

// src/setting.ts
var structureMap = {
  keyValue: "key-value",
  keyArray: "key-array"
};
var formatMap = {
  stack: "- item",
  flat: "[item]"
};
var DEFAULT_SETTINGS = {
  stateMaps: [
    {
      key: "state",
      structure: "keyValue",
      values: ["waiting", "ongoing", "completed"]
    }
  ]
};
var FileStateSwitcherSettingTab = class extends import_obsidian2.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Yaml Manager Settings" });
    this.renderNewSettingItemButton(containerEl);
    this.plugin.settings.stateMaps.forEach((field, fieldIndex, fields) => {
      const s = new import_obsidian2.Setting(this.containerEl);
      s.controlEl.addClass("fss-setting-control");
      this.renderSettingItem(s, field, fieldIndex, fields);
      s.infoEl.remove();
    });
  }
  renderNewSettingItemButton(containerEl) {
    new import_obsidian2.Setting(containerEl).setName("Add map").setDesc("Add new key-values map").addButton((button) => {
      button.setTooltip("Add additional map").setButtonText("+").onClick(() => {
        this.plugin.settings.stateMaps.push({
          key: "",
          structure: "keyValue",
          values: [""]
        });
        this.plugin.saveSettings();
        this.display();
      });
    });
  }
  renderSettingItem(s, field, fieldIndex, fields) {
    const metaContainer = s.controlEl.createDiv();
    metaContainer.addClass("fss-meta");
    this.renderMeta(s, metaContainer, field);
    const fieldContainer = s.controlEl.createDiv();
    fieldContainer.addClass("fss-field");
    this.renderField(s, fieldContainer, fields, fieldIndex);
    const valueContainer = s.controlEl.createDiv();
    valueContainer.addClass("fss-values");
    this.renderValue(s, valueContainer, field.values, fields, fieldIndex);
  }
  renderMeta(setting, container, field) {
    const settingItemContainer = container.createDiv({ cls: "setting-item" });
    const infoContainer = settingItemContainer.createDiv({ cls: "setting-item-info" });
    infoContainer.createDiv({ cls: "setting-item-name", text: "Structure" });
    infoContainer.createDiv({ cls: "setting-item-description", text: "Value structure of this field" });
    setting.addDropdown((cb) => {
      var _a;
      cb.addOptions(structureMap).setValue((_a = field.structure) != null ? _a : "keyValue").onChange((value) => {
        if (value === "keyValue")
          delete field.format;
        field.structure = value;
        this.plugin.saveSettings();
        this.display();
      });
    });
    settingItemContainer.appendChild(setting.controlEl.lastChild);
    if (field.structure === "keyArray") {
      const settingItemContainer2 = container.createDiv({ cls: "setting-item" });
      const infoContainer2 = settingItemContainer2.createDiv({ cls: "setting-item-info" });
      infoContainer2.createDiv({ cls: "setting-item-name", text: "Format" });
      infoContainer2.createDiv({ cls: "setting-item-description", text: "Value format of this field" });
      setting.addDropdown((cb) => {
        var _a;
        cb.addOptions(formatMap).setValue((_a = field.format) != null ? _a : "stack").onChange((value) => {
          field.format = value;
          this.plugin.saveSettings();
          this.display();
        });
      });
      settingItemContainer2.appendChild(setting.controlEl.lastChild);
    }
  }
  renderField(setting, container, keys, keyIdx) {
    setting.addExtraButton((button) => {
      button.setIcon("cross").setTooltip("Delete key").onClick(() => {
        itemDelete(keys, keyIdx);
        this.plugin.saveSettings();
        this.display();
      });
    });
    container.appendChild(setting.controlEl.lastChild);
    setting.addText((text) => {
      text.setPlaceholder("Field").setValue(keys[keyIdx].key).onChange((newField) => {
        keys[keyIdx].key = newField;
        this.plugin.saveSettings();
      });
    });
    container.appendChild(setting.controlEl.lastChild);
  }
  renderValue(setting, container, values, keys, keyIdx) {
    values.forEach((value, valueIndex, values2) => {
      const valueContainer = setting.controlEl.createDiv();
      valueContainer.addClass("fss-values-value");
      container.appendChild(valueContainer);
      setting.addText((text) => {
        text.setPlaceholder(`Value${valueIndex + 1}`).setValue(value).onChange((newValue) => {
          values2[valueIndex] = newValue;
          this.plugin.saveSettings();
        });
      });
      valueContainer.appendChild(setting.controlEl.lastChild);
      setting.addExtraButton((cb) => {
        cb.setIcon("up-chevron-glyph").setTooltip("Move up").onClick(() => {
          if (valueIndex !== 0) {
            itemMove(values2, valueIndex - 1, valueIndex);
            this.plugin.saveSettings();
            this.display();
          }
        });
      });
      valueContainer.appendChild(setting.controlEl.lastChild);
      setting.addExtraButton((cb) => {
        cb.setIcon("down-chevron-glyph").setTooltip("Move down").onClick(() => {
          if (valueIndex !== values2.length - 1) {
            itemMove(values2, valueIndex, valueIndex + 1);
            this.plugin.saveSettings();
            this.display();
          }
        });
      });
      valueContainer.appendChild(setting.controlEl.lastChild);
      setting.addExtraButton((cb) => {
        cb.setIcon("plus").setTooltip("Add").onClick(() => {
          itemAdd(values2, valueIndex + 1, "");
          this.plugin.saveSettings();
          this.display();
        });
      });
      valueContainer.appendChild(setting.controlEl.lastChild);
      setting.addExtraButton((cb) => {
        cb.setIcon("cross").setTooltip("Delete").onClick(() => {
          if (values2.length === 1) {
            itemDelete(keys, keyIdx);
          } else {
            itemDelete(values2, valueIndex);
          }
          this.plugin.saveSettings();
          this.display();
        });
      });
      valueContainer.appendChild(setting.controlEl.lastChild);
    });
  }
};

// src/suggester.ts
var import_obsidian3 = __toModule(require("obsidian"));
var Suggester = class extends import_obsidian3.FuzzySuggestModal {
  constructor(app, displayItems, items) {
    super(app);
    this.displayItems = displayItems;
    this.items = items;
    this.state = "pending";
    this.promise = new Promise((resolve, reject) => {
      this.resolvePromise = (value) => {
        this.state = "resolved";
        resolve(value);
      };
      this.rejectPromise = (reason) => {
        this.state = "rejected";
        reject(reason);
      };
    });
    this.open();
  }
  static Suggest(app, displayItems, items) {
    const suggester = new Suggester(app, displayItems, items);
    return suggester.promise;
  }
  getItems() {
    return this.items;
  }
  getItemText(item) {
    return this.displayItems[this.items.indexOf(item)];
  }
  onChooseItem(item, evt) {
  }
  selectSuggestion(value, evt) {
    this.resolvePromise(value.item);
    super.selectSuggestion(value, evt);
  }
  onClose() {
    if (this.state !== "resolved")
      this.rejectPromise("Nothing selected");
    super.onClose();
  }
};

// src/bulkUpdateModal.ts
var import_obsidian4 = __toModule(require("obsidian"));
var BulkUpdateModal = class extends import_obsidian4.Modal {
  constructor(app, settings, currentFrontmatter) {
    super(app);
    this.state = "pending";
    this.promise = new Promise((resolve, reject) => {
      this.resolvePromise = (value) => {
        this.state = "resolved";
        resolve(value);
      };
      this.rejectPromise = (reason) => {
        this.state = "rejected";
        reject(reason);
      };
    });
    this.generateData(settings, currentFrontmatter);
    this.renderModal();
    this.addConfirm();
    this.addClose();
    this.open();
  }
  static Generate(app, settings, currentFrontmatter) {
    return __async(this, null, function* () {
      const modal = new BulkUpdateModal(app, settings, currentFrontmatter);
      return modal.promise;
    });
  }
  renderModal() {
    const { modalEl, titleEl } = this;
    modalEl.classList.add("yaml_manager-bulk_update_modal");
    titleEl.setText("Yaml");
    this.renderModalContent();
  }
  renderModalContent() {
    const { contentEl } = this;
    contentEl.empty();
    this.datas.forEach((field) => {
      const fieldContainer = contentEl.createDiv();
      fieldContainer.classList.add("field");
      const fieldKeyContainer = fieldContainer.createDiv();
      fieldKeyContainer.classList.add("field_key_container");
      const applyFieldSwitcher = this.addCheckBox(fieldKeyContainer, {
        change: (event) => {
          field.apply = !field.apply;
          this.renderModalContent();
        }
      });
      applyFieldSwitcher.checked = field.apply;
      fieldKeyContainer.appendText(field.key + ":");
      const fieldValuesContaienr = fieldContainer.createDiv();
      fieldValuesContaienr.classList.add("field_value_container");
      field.values.forEach((value) => {
        const label = fieldValuesContaienr.createEl("label");
        label.classList.add("field_value");
        let input;
        if (field.structure === "keyValue") {
          input = this.addRadio(label, {
            change: (e) => {
              field.current = e.target.value;
            }
          });
          input.checked = field.current === value ? true : false;
        }
        if (field.structure === "keyArray") {
          input = this.addCheckBox(label, {
            change: (e) => {
              const value2 = e.target.value;
              field.current.has(value2) ? field.current.delete(value2) : field.current.add(value2);
            }
          });
          input.checked = field.current.has(value) ? true : false;
        }
        if (!applyFieldSwitcher.checked) {
          input.disabled = true;
          input.classList.add("disabled");
        }
        input.name = field.key;
        input.value = value;
        label.appendText(value);
      });
    });
  }
  generateData(settings, currentFrontmatter) {
    this.datas = [];
    settings.forEach(({ key, values, structure }) => {
      const apply = currentFrontmatter[key] ? true : false;
      let current;
      if (structure === "keyValue")
        current = typeof currentFrontmatter[key] === "string" ? currentFrontmatter[key] : "";
      if (structure === "keyArray")
        current = currentFrontmatter[key] instanceof Array ? new Set(currentFrontmatter[key]) : new Set([]);
      this.datas.push({ key, values, apply, structure, current });
    });
  }
  addCheckBox(container, options) {
    return this.addInput(container, "checkbox", options);
  }
  addRadio(container, options) {
    return this.addInput(container, "radio", options);
  }
  addInput(container, type, options) {
    const input = container.createEl("input");
    input.type = type;
    options && Object.entries(options).forEach(([event, handler]) => {
      input.addEventListener(event, (e) => {
        handler(e);
      });
    });
    return input;
  }
  addConfirm() {
    const confirmBtn = this.addBtn("Confirm");
    confirmBtn.addEventListener("click", () => {
      this.onConfirm();
    });
  }
  addClose() {
    const closeBtn = this.addBtn("Close");
    closeBtn.addEventListener("click", () => {
      this.close();
    });
  }
  addBtn(text) {
    const { modalEl } = this;
    let container = modalEl.querySelector(".btn_container");
    if (!container) {
      container = modalEl.createDiv();
      container.addClass("btn_container");
    }
    const btn = container.createEl("button");
    btn.classList.add(`btn_${text.toLowerCase()}`);
    btn.setText(text);
    return btn;
  }
  onConfirm() {
    const result = {};
    this.datas.forEach((data) => {
      if (!data.apply)
        return;
      if (data.structure === "keyValue")
        result[data.key] = data.current || void 0;
      if (data.structure === "keyArray")
        result[data.key] = [...data.current];
    });
    this.resolvePromise(result);
    this.close();
  }
  onClose() {
    if (this.state === "pending") {
      this.rejectPromise("Modal closed.");
    }
  }
};

// src/version.ts
function makeCompatible(setting) {
  setting.stateMaps.forEach((map) => {
    var _a;
    map.structure = (_a = map.structure) != null ? _a : "keyValue";
  });
  return setting;
}

// src/main.ts
var StateSwitcherPlugin = class extends import_obsidian5.Plugin {
  constructor() {
    super(...arguments);
    this.constants = {
      turnBack: "\u2B05\uFE0F Back"
    };
  }
  onload() {
    return __async(this, null, function* () {
      console.log("Loading State Switcher");
      yield this.loadSettings();
      this.addCommand({
        id: "keyValueUpdate",
        name: "key-value update",
        editorCallback: (editor, view) => __async(this, null, function* () {
          const source = this.settings.stateMaps.filter((field) => {
            return field.structure === "keyValue";
          });
          let selectionResult;
          try {
            selectionResult = yield this.getUserSelection(editor, source);
          } catch (error) {
            console.log(error);
          }
          if (!selectionResult)
            return;
          const { selectedKey, selectedValue } = selectionResult;
          replace(selectedKey, selectedValue, editor);
        })
      });
      this.addCommand({
        id: "keyArrayInsert",
        name: "key-array insert",
        editorCallback: (editor, view) => __async(this, null, function* () {
          const source = this.settings.stateMaps.filter((field) => {
            return field.structure === "keyArray";
          });
          let selectionResult;
          try {
            selectionResult = yield this.getUserSelection(editor, source, "insert");
          } catch (error) {
            console.log(error);
          }
          if (!selectionResult)
            return;
          const { selectedKey, selectedValue } = selectionResult;
          const shouldFlat = this.getFlatFields().includes(selectedKey);
          insert(selectedKey, selectedValue, shouldFlat, editor);
        })
      });
      this.addCommand({
        id: "keyArrayRemove",
        name: "key-array remove",
        editorCallback: (editor, view) => __async(this, null, function* () {
          const source = this.settings.stateMaps.filter((field) => {
            return field.structure === "keyArray";
          });
          let selectionResult;
          try {
            selectionResult = yield this.getUserSelection(editor, source, "remove");
          } catch (error) {
            console.log(error);
          }
          if (!selectionResult)
            return;
          const { selectedKey, selectedValue } = selectionResult;
          const shouldFlat = this.getFlatFields().includes(selectedKey);
          remove(selectedKey, selectedValue, shouldFlat, editor);
        })
      });
      this.addCommand({
        id: "bulkUpdate",
        name: "bulk update",
        editorCallback: (editor, view) => __async(this, null, function* () {
          const currentFrontmatter = getObjectYaml(editor);
          let updateDatas;
          try {
            updateDatas = yield BulkUpdateModal.Generate(this.app, this.settings.stateMaps, currentFrontmatter);
          } catch (error) {
            console.log(error);
          }
          if (!updateDatas)
            return;
          const removeDatas = this.settings.stateMaps.flatMap((field) => {
            return updateDatas[field.key] ? [] : [field.key];
          });
          const flatFields = this.getFlatFields().filter((key) => key in updateDatas);
          bulkUpdate(updateDatas, removeDatas, flatFields, editor);
        })
      });
      this.addSettingTab(new FileStateSwitcherSettingTab(this.app, this));
    });
  }
  onunload() {
  }
  loadSettings() {
    return __async(this, null, function* () {
      const settings = Object.assign({}, DEFAULT_SETTINGS, yield this.loadData());
      this.settings = makeCompatible(settings);
    });
  }
  saveSettings() {
    return __async(this, null, function* () {
      yield this.saveData(this.settings);
    });
  }
  getUserSelection(editor, source, action) {
    return __async(this, null, function* () {
      source = source != null ? source : this.settings.stateMaps;
      const currentFrontmatter = getObjectYaml(editor);
      const nonEmptyField = action === "remove" ? source.filter((map) => map.key && currentFrontmatter[map.key]) : source.filter((map) => map.key);
      if (!nonEmptyField.length) {
        action === "remove" ? new import_obsidian5.Notice("Nothing can be removed") : new import_obsidian5.Notice("No map founded, please check your config");
        return;
      }
      const keys = nonEmptyField.map((field) => field.key);
      try {
        const selectedKey = yield Suggester.Suggest(this.app, keys, keys);
        let values = nonEmptyField.find((field) => field.key === selectedKey).values.filter((values2) => values2);
        if (action) {
          const currentValues = currentFrontmatter[selectedKey];
          if (currentValues) {
            if (action === "insert")
              values = values.filter((value) => !currentValues.includes(value));
            if (action === "remove")
              values = values.filter((value) => currentValues.includes(value));
          }
        }
        values.push(this.constants.turnBack);
        const selectedValue = yield Suggester.Suggest(this.app, values, values);
        if (selectedValue === this.constants.turnBack)
          return yield this.getUserSelection(editor, source, action);
        return { selectedKey, selectedValue };
      } catch (error) {
        console.log(error);
      }
    });
  }
  getFlatFields() {
    return this.settings.stateMaps.filter((setting) => setting.format === "flat").map((setting) => setting.key);
  }
};


/* nosourcemap */